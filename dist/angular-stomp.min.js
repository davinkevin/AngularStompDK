!function(){"use strict";var _createClass=function(){function defineProperties(target,props){for(var key in props){var prop=props[key];prop.configurable=!0,prop.value&&(prop.writable=!0)}Object.defineProperties(target,props)}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},ngstompProvider=function(){function ngstompProvider(){_classCallCheck(this,ngstompProvider),this.settings={}}return _createClass(ngstompProvider,{credential:{value:function(login,password){return this.settings.login=login,this.settings.password=password,this}},url:{value:function(_url){var _urlWrapper=function(){return _url.apply(this,arguments)};return _urlWrapper.toString=function(){return _url.toString()},_urlWrapper}(function(url){return this.settings.url=url,this})},"class":{value:function(clazz){return this.settings["class"]=clazz,this}},settings:{value:function(settingsObject){return this.settings=settingsObject,this}},debug:{value:function(boolean){return this.settings.debug=boolean,this}},vhost:{value:function(host){return this.settings.vhost=host,this}},$get:{value:["$q","$log","$rootScope",function($q,$log,$rootScope){return new ngStompWebSocket(this.settings,$q,$log,$rootScope)}]}}),ngstompProvider}(),ngStompWebSocket=function(){function ngStompWebSocket(settings,$q,$log,$rootScope){_classCallCheck(this,ngStompWebSocket),this.settings=settings,this.$q=$q,this.$rootScope=$rootScope,this.stompClient=settings["class"]?Stomp.over(new settings["class"](settings.url)):Stomp.client(settings.url),this.stompClient.debug=settings.debug?$log.debug:function(){},this.connections=[],this.deferred=this.$q.defer(),this.promiseResult=this.deferred.promise,this.connect()}return _createClass(ngStompWebSocket,{connect:{value:function(){var _this=this;return this.stompClient.connect(this.settings.login,this.settings.password,function(){_this.deferred.resolve(),_this.$digestStompAction()},function(){_this.deferred.reject(),_this.$digestStompAction()},this.settings.vhost),this.promiseResult}},subscribe:{value:function(url,callback,scope){var _this=this;return this.promiseResult.then(function(){_this.$stompSubscribe(url,callback),_this.unRegisterScopeOnDestroy(scope,url)}),this}},unsubscribe:{value:function(url){var _this=this;return this.promiseResult.then(function(){return _this.$stompUnSubscribe(url)}),this}},send:{value:function(queue,data,header){var _this=this,sendDeffered=this.$q.defer();return this.promiseResult.then(function(){_this.stompClient.send(queue,header||{},JSON.stringify(data)),sendDeffered.resolve()}),sendDeffered.promise}},disconnect:{value:function(){var _this=this,disconnectionPromise=this.$q.defer();return this.stompClient.disconnect(function(){disconnectionPromise.resolve(),_this.$digestStompAction()}),disconnectionPromise.promise}},$stompSubscribe:{value:function(queue,callback){var _this=this,_arguments=arguments,subscription=this.stompClient.subscribe(queue,function(){callback.apply(_this.stompClient,_arguments),_this.$digestStompAction()});this.connections.push({url:queue,subscription:subscription})}},$stompUnSubscribe:{value:function(queue){for(var indexToRemove=!1,i=0,len=this.connections.length;len>i;i++)if(this.connections[i].url===queue){indexToRemove=i,this.connections[i].subscription.unsubscribe();break}indexToRemove!==!1&&this.connections.splice(indexToRemove,1)}},$digestStompAction:{value:function(){!this.$rootScope.$$phase&&this.$rootScope.$apply()}},unRegisterScopeOnDestroy:{value:function(scope,url){var _this=this;void 0!==scope&&angular.isFunction(scope.$on)&&scope.$on("$destroy",function(){return _this.unsubscribe(url)})}}}),ngStompWebSocket}();angular.module("AngularStompDK",[]).provider("ngstomp",ngstompProvider)}();
//# sourceMappingURL=angular-stomp.min.js.map